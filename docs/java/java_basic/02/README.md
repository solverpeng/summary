# JAVA虚拟机

## JVM垃圾回收机制
垃圾：特指内存中不会再被是使用的对象。
关键：识别和清除垃圾对象

### 常用的垃圾回收算法
#### 引用计数法
原理：对于一个对象A，只要任何一个对象引用了A，则A的引用计数器就加1，当引用失效时，则引用计数器减1。只要当引用计数器值为0时，就回收A对象。
实现非常简单，为每个对象分配一个引用计数器就可以。但是会存在两个非常严重的问题：
1. 无法处理循环引用的问题
2. 引用计数器在每次做加法操作或减法操作，堆性能会有一定的影响

一个简单的循环引用的问题描述：
有对象A/B，对象A中含有对象B的引用，对象B中含有对象A的引用。但是在系统中却不存在第三个对象引用了A和B。也就是说A/B是应该被回收的垃圾对象。由于对象间的相互引用，从而是垃圾回收器无法识别，引起内存泄露。
Java并未选择此种算法进行垃圾回收。

#### 标记清除法
标记阶段：
从根节点开始，标记所有可达的对象，未被标记的对象就是未被引用的垃圾对象。

清除阶段：
清除所有为被标记的不可达对象，即垃圾对象

缺陷：
产生空间碎片。回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的内存空间的工作效率要低于连续内存空间。

简言之，标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。

#### 复制算法
将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中存活的对象复制一份到新的内存空间中，因此可以确保回收后的空间是没有碎片的。

缺点：需要将内存折半。

在JAVA新生代串行垃圾回收器中，使用了复制算法的思想。新生代分为eden空间/from空间/to空间3个部分。其中 from/to 可以看作是两块相同的/可以进行角色互换的空间块。from/to空间也称为survivor空间，即幸存者空间，用于存放未被回收的对象。
在垃圾回收时，eden空间中存活的对象会被复制到未被使用的survivor空间中（假设是to），正在使用的空间（假设是from）中的年轻对象也会被复制到to空间中（大对象或是老年对象会直接进入老年代）。此时 eden 空间和 from 空间中就是垃圾对象，可以直接清空，to空间则存放此次回收后的存活的对象。
这种改进的复制算法，既保证了空间的连续性，又避免了大量的内存空间的浪费。
复制算法比较适用于新生代，因为在新生代，垃圾对象通常会多于存活对象。复制算法的效果会比较好。

#### 标记压缩算法
复制算法适用于存活对象少，垃圾对象多的情况下。但是在老年代，如果依然使用复制算法，由于存活对象较多，复制的成本将很高。
基于老年代存活对象多，而垃圾对象少的特点，使用标记压缩算法进行回收。

标记清除算法是一种老年代的回收算法，它在标记清除算法的基础进行了一些优化，和标记清除法类似，标记压缩法也首先需要从根节点开始，对所有可达的对象做一次标记，但是之后并不只是简单的清理未被标记的对象，而是将所有存活的对象压缩到内存的一端，之后清理边界的所有空间，这种方式既避免了碎片的产生，又不需要两块相同的内存空间。

### 分代算法
根据垃圾回收对象的特性，使用合适的算法回收，才是明智的选择。
分代思想被现有的虚拟机广泛使用几乎所有的垃圾回收器都区分新生代和老年代。
新生代使用复制算法进行垃圾回收，而老年代使用标记压缩算法进行垃圾回收。

对于新生代和老年代来说，通常新生代回收的频率很高，而老年代回收的频率较低，但是会消耗更多的时间。
为了支持高频的新生代的回收，虚拟机可能使用一种叫做卡表的数据结构。卡表为一个比特位的集合，每一个比特位可以用来表示老年代的某一个区域中的所有对象是否持有新生代对象的引用。这样可以在新生代GC时，不用花大量时间去扫描所有的老年代，来确定每一个对象的引用关系，而可以先扫描卡表，只有的那个卡表的标记位为1时，才需要扫描给定区域的老年代对象，而0表示所在区域的老年代对象，一定不含有新生代对象的引用。
这样，可以大大加快新生代的回收速度。

### 分区算法
分代算法是按照对象的生命周期长短划分为两部分。
分区算法将整个堆空间划分为连续的不同小区间，每个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。
一般来说，在相同情况下，堆空间越大，一次GC所需要的时间就越长，从而产生的停顿也越长。为了更好的控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次GC所产生的停顿。

### 谁才是真正的垃圾
垃圾回收的基本思想是考察每一个对象的可触及性。
可触及的：从根节点开始，可以到达这个对象。
可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 函数中复活。
不可触及的：对象的 finalize() 函数被调用，并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因此 finalize() 函数只会被调用一次。

finalize() 函数是一个非常糟糕的的模式，不推荐使用 finalize() 函数释放资源。
第一，因为 finalize() 函数可能引发引用外泄，在无意中复活对象。
第二，由于 finalize() 是被系统调用的，调用时间不明确，因此不是一个好的资源释放方案，推荐使用 try-catch-finally 语句中进行资源的释放。

### 引用和可触及性的强度
4个级别的引用：强引用/软引用/弱引用/虚引用，除强引用外，其他的3个级别的引用都可以在java.lang.ref包中找到他们的身影。

#### 强引用
强引用就是程序中一般的引用类型，强引用的对象是可触及的，不会被回收的。相对的，软引用/弱引用和虚引用的对象是软可触及的/弱可触及的和虚可触及的，在一定条件下，是可以被回收的。
一个例子：
StringBuffer str = new StringBuffer("hello world");
局部变量 str 指向 StringBuffer 实例所在的堆空间，通过 str 可以操作该实例，那么 str 就是StringBuffer实例的强引用。
此时，再运行一个赋值语句：
StringBuffer str1 = str;
那么 str 所指向的对象也将被 str1 所指向。

强引用具备以下特点：
1. 强引用可以直接访问目标对象
2. 强引用所指向的对象在任何时候都不会被回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向的对象。
3. 强引用可能导致内存泄露。

#### 软引用（SoftReference）
软引用是比强引用弱一点的引用类型。一个对象只持有软引用，那么当堆空间不足时，就会被回收。
GC未必会回收软引用的对象，但是，当内存资源紧张时，软引用对象就会被回收，所以软引用对象不会引起内存溢出。

#### 弱引用
弱引用是一种比较弱的引用类型。在系统GC时，只要发现弱引用，不管堆空间如何，都会将对象进行回收。
但是，由于垃圾回收器的线程通常优先级较低，因此，并不能很快的发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。弱引用使用 java.lang.ref.WeakReference类实现。

软引用和弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据有可以存在相当长的时间，从而起到加速系统的作用。

#### 虚引用
虚引用是所有引用类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一模一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的 get() 方法来得到强引用时，总会失败。并且虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。

当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。

## JAVA代码编译和执行的过程
JAVA 代码编译是由 Java 源码编译器来完成的，流程如下：
源代码——词法分析器——Token流——语法分析器——语法树/抽象语法树——语义分析器——注解抽象语法树——字节码生成器——JVM字节码
Java 字节码的执行是由 JVM 执行引擎来执行的，流程如下：
JVM 字节码——机器无关代码优化——中间代码——机器相关优化——中间代码——寄存器分配器——中间代码——目标代码生成器——目标代码

代码编译和执行的整个过程包含了一下三个重要的机制:
### Java 源码编译机制
分析和输入到符号表——注解处理——语义分析和生成 class 文件

### 类加载机制
JVM 类是通过 ClassLoader 及其子类来完成的，类的层次关系和加载顺序如下：
自底向上检查类是否已经加载：
Customer ClassLoader —— App ClassLoader —— Extension ClassLoader —— Bootstrap ClassLoader
自顶向下尝试加载类：
Bootstrap ClassLoader 负责加载 JRE/lib/rt.jar 包中所有的 class。
Extension ClassLoader 负责加载`JRE/lib/*.jar` 包中所有的 class。
App ClassLoader 负责加载 classpath 中指定的 jar 包以及目录中的 class。
Customer ClassLoader 应用程序根据自己需要自定义类加载器。

### 类执行机制
JVM 是基于栈的体系结构来执行 class 字节码的。线程创建后，都会产生程序计数器和栈，程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。

## JAVA虚拟机构成以及内存区域划分
Java虚拟机由执行引擎/垃圾回收系统/方法区/Java堆/直接内存/Java栈/本地方法栈/PC寄存器（程序计数器）/类加载子系统构成。

### 类加载子系统
类加载子系统负责从文件系统或网络中加载 Class 信息，加载的类信息存放于一块称为方法区的内存空间。

### 方法区
类加载子系统加载后的 Class信息，会存放到方法区中。除类信息外，方法区中还会存放运行时的常量信息，包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射），静态变量，即时编译器编译后的代码等数据。

运行时常量池是方法区的一部分。Class文件中除了有类的版本/字段/方法/接口等描述信息外，还有一项是常量池，用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
运行时常量池相对于Class文件常量池的另一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，运行期也能将新的常量放入池中，使用比较多的是 String 的 intern() 方法。

和Java堆一样，方法区是一块所有线程共享的内存区域。用于保存系统的类信息，比如类的字段/方法/常量池。方法区的大小决定了系统可以保存多少个类，若系统定义了太多的类，会导致方法区溢出，虚拟机同样会抛出内存溢出的错误。
在 JDK1.6和JDK1.7中，方法区可以理解为永久区（Perm）。永久区可以使用参数-XX:PermSize 和 -XX:MaxPermSize来指定。若系统使用了动态代理，那么有可能在运行时会产生大量的类。

在 JDK1.8 中，永久区已被彻底移除，取而代之的是元数据区。元数据区大小可以使用 -XX:MaxMetaspaceSize 来指定，这是一块堆外的直接内存。
和永久区不同，如果不指定大小，默认情况下，虚拟机会耗尽所有可用的系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常。

### Java堆
Java堆在Java虚拟机启动的时候建立，它是Java程序最主要的内存工作区域。几乎所有的Java对象实例都存放在这里。堆空间是线程共享的。

### 直接内存
Java 的NIO 库允许Java程序使用直接内存。直接内存是Java堆外的，直接向系统申请的内存空间。通常，访问直接内存的速度会优于Java堆。
由于直接内存在Java堆外，因此它的大小不会直接受限于Xmx指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和大小依然受限于操作系统能给出的最大内存。

### 垃圾回收系统
垃圾回收系统是Java虚拟机重要的组成部分，垃圾回收器会对方法区，Java堆和直接内存进行回收。其中，Java堆是垃圾回收器的工作重点，因此Java堆也称为GC堆。

### Java栈
每一个 Java 虚拟机线程都有一个私有的Java栈。一个线程的Java栈，在线程创建的时候被创建。Java栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧，栈帧中存储着局部变量表/操作数栈/动态链接/方法出口等信息。每个方法从调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中入栈和出栈的过程。
经常有人把Java内存区分为堆和栈。实际上的划分远远比这复杂。这种划分方式流行只能说明大多数程序员最关心的，与对象内存分配关系最密切的内存区域就是这两块。
这里所说的栈就是Java虚拟机栈，更具体的来讲，指的是Java虚拟机栈中的局部变量表部分。局部变量表存放了编译器可知的各种基本数据类型，对象引用和 returnAddress 类型。
其中64为长度的 long 和 double 类型的数据会占用2个局部变量空间，其余的数据类型只占一个。局部变量表所需的内存空间在编译期就完成了分配，当进入一个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间是不会改变局部变量表的大小的。

局部变量表是栈帧的重要组成部分之一，用于保存函数的参数以及局部变量。局部变量表中的变量只在当前函数调用中有效，当函数调用结束，随着函数栈帧的销毁，局部变量表也会随之销毁。由于局部变量表在栈帧中，因此，如果函数的参数和局部变量较多，会使得局部变量表膨胀，从而每一次函数调用就会占用更多的栈空间，最终导致函数的嵌套调用次数减少。

局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都是不会被回收的。

操作数栈也是栈帧的重要内容之一，主要用于保存计算过程的中间结果，同时作为计算过程中变量的临时存储空间。操作数栈也是一个先进后出的数据结构，只支持入栈和出栈两种操作。

帧数据区：大部分Java字节码指令需要进行常量池访问，在帧数据区中保存着访问常量池的指针，方便程序访问常量池。
异常处理表也是栈帧区中重要的一部分。

### 本地方法栈
和 Java栈类似，最大的不同在于 Java栈用于Java方法的调用，而本地方法栈则用于本地方法的调用。Java虚拟机允许Java方法直接调用本地方法。

### 程序计数器
也称为PC寄存器，是每个线程私有的（Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的）。Java虚拟机会为每个线程创建PC寄存器。在任意时刻，一个Java线程总是在执行一个方法，这个正在被执行的方法称为当前方法。
若当前方法不是本地方法，PC寄存器会指向当前正在被执行的指令，若当前方法是本地方法，PC寄存器的值为 undifined。

### 执行引擎
负责执行虚拟机的字节码。

### 运行时数据区
包括方法区/Java堆/Java栈/本地方法栈/程序计数器。
直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。

### 对象去哪儿：Java堆
通过下面一个简单的实例，来展示Java堆/方法区和Java栈之间的关系
```java
public class SimpleHeap {
    private int id;

    public SimpleHeap(int id) {
        this.id = id;
    }

    public void show() {
        System.out.println("My Id is " + id);
    }

    public static void main(String[] args) {
        SimpleHeap s1 = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);

        s1.show();
        s2.show();
    }
}
```
声明了一个 SimpleHeap 类，并在main() 中创建了两个 SimpleHeap 实例。SimpleHeap 实例本身分配在堆中，描述 SimpleHeap类的信息存放在方法区，main()
函数中 s1 和 s2 局部变量存放在 Java 栈中，并指向堆中的两个实例。

![](https://xiaozhang-image.oss-cn-shanghai.aliyuncs.com/github/java-summary/java-basic/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png)

### 函数如何调用：出入Java栈
如果说，Java堆和程序数据密切相关，那么Java栈就是和线程执行密切相关。线程执行的基本行为是函数调用，每次函数调用的数据都是通过Java栈传递的。
Java栈和数据结构上的栈有着类似的含义，它是一块先进后出的数据结构，只支持出栈和入栈两种操作。在Java栈中保存的主要内容为栈帧。每次函数调用，都会有一个栈帧被压入Java栈，每一个函数调用结束，都会有一个栈帧被弹出Java栈。当前正在执行的函数所对应的帧位于栈顶，它保存着当前函数的局部变量/中间运算结果等数据。当函数返回时，栈帧从Java栈中被弹出。Java方法有两种返回函数的方式。一种是正常函数返回，使用return指令；另一种是抛出异常。不管是那种方式，都会导致栈帧被弹出。在一个栈帧中，至少要包含局部变量表/操作数栈和帧数据区几个部分。

![](https://xiaozhang-image.oss-cn-shanghai.aliyuncs.com/github/java-summary/java-basic/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png)

由于每次函数调用都会生成对应哪个的栈帧，从而占用一定的栈空间。若栈空间不足，那么函数调用自然无法继续，当请求的线程深度大于最大可用栈深度时，系统会抛出 StackOverflowError 栈溢出错误。Java虚拟机提供了 -Xss 来制定线程的最大栈空间，这个参数直接决定了函数调用的最大深度。

## 常用 Java 虚拟机参数

### GC（垃圾回收）
-XX：+PrintGC，启动Java虚拟机后，只要遇到GC，就会打印日志。
-XX：+PrintGCDetails，可以打印更加详细的GC日志信息，还会使虚拟机在退出前打印堆的详细信息。
-XX：+PrintHeapAtGC，可以打印更加全面的堆信息。
-XX：+PrintGCTimeStamps，分析GC发生的时间。
-XX: +PrintGCApplicationConcurrentTime，可以打印应用程序的执行时间。
-XX: +PrintGCApplicationStoppedTime，可以打印由于GC而产生的停顿时间。
-XX：+PrintReferenceGC，可以跟踪系统内的软引用/若引用/虚引用/Finallize队列。
-Xloggc：log/gc.log，默认情况下，GC的日志会在控制台中输出，使用该参数可以使GC日志以文件的形式输出。

### 类加载/卸载的跟踪
-verbose:class：跟踪类的加载和卸载
-XX:+ TraceClassLoading 跟踪类的加载
-XX:+TraceClassUnloading 跟踪类的卸载
-XX:+PrintClassHistogram 允许在运行时打印/查看系统中类的分布情况。在Java控制台按下 Ctrl+Break 组合键。

### 系统参数查看
-XX：+PrintVMOptions，在程序运行时，打印虚拟机接受到的命令行显式参数。
-XX：+PrintCommandLineFlags 可以打印传递给虚拟机的显式和隐式参数。
-XX：+PrintFlagsFinal，会打印所有的系统参数的值。

### 堆的配置参数

#### 最大堆和初始堆的设置
初始堆：-Xms 指定这块空间的大小，初始堆空间耗尽后，虚拟机将会对堆空间进行扩展，扩展上限为最大堆空间
最大堆空间：-Xmx 来指定。

#### 新生代的配置
-Xmn 可以用来设置新生代的大小。设置一个较大的新生代会减少老年代的大小，这个参数堆系统性能以及GC行为有很大的影响。
新生代的大小的一般设置为堆空间的1/3到1/4左右。

-XX:SurivorRatio用来设置新生代中eden空间和from/to空间的比例关系。含义：-XX:SurivorRatio=eden/from=eden/to.
在实际工作中，应该根据系统的特点做合理的设置，基本策略是：尽可能就对象预留在新生代，减少老年代GC的次数。

-XX:NewRatio 用来设置新生代和老年代的比例。含义：-XX:NewRatio=老年代/新生代。

### 堆溢出
在Java程序运行的过程中，如果堆内存不足，则有可能抛出OOM（Out Of Memory），如果发生 OOM，系统就会被迫退出。
-XX:+HeapDumpOnOutOfMemoryError 参数：可以在内存溢出时到处整个堆的信息。
-XX:HeapDumpPath 参数：可以指定导出堆的存放路径。

### 非堆内存的参数配置
#### 方法区配置
在JDK1.6和JDK1.7等版本中，可以使用-XX:PermSize和-XX:MaxPermSize配置永久区的大小。其中-XX:PermSize表示初始的永久区的大小，
-XX:MaxPermSize表示最大永久区。

在JDK1.8中，永久区被移除，使用了新的元数据区存储元数据。-XX:MaxMetaspaceSize 指定永久区的最大可用值。

#### 栈配置
-Xss参数指定线程的栈大小。

#### 直接内存配置
-XX:MaxDirectMemorySize 最大可用直接内存。若不设置，默认为最大堆空间。
当直接内存使用量达到-XX:MaxDirectMemorySize时，就会触发垃圾回收，如果垃圾回收不能有效释放足够空间，直接内存溢出依然会引起系统的 OOM。
直接内存的读写速度会快于堆内存，但是申请内存空间时，堆空间的速度远远高于直接内存。

结论：直接内存适合申请次数较少/访问较频繁的场合。

## 虚拟机的工作模式
Java虚拟机支持Client和Server两种运行模式。使用参数 -client 可以指定使用 Client模式，使用 -server可以指定 Server模式。使用 -version 可以查看当前模式。

### 类加载顺序

### 初始化顺序
在单一对象的情况下，执行顺序是这样的，按静态成员的先后顺序先执行静态的，然后初始化非静态成员（成员变量、代码块），然后再执行构造器存在继承的情况下，父类的初始化在子类之前。

## 参数传递
```java
@Test
public void testTransfer() {
    int num = 12;
    print(num);
    System.out.println(num);
}

@Test
public void testTransfer2() {
    String str = "abc";
    print(str);
    System.out.println(str);
}

@Test
public void testTransfer3() {
    StringBuffer sb = new StringBuffer("abc");
    print(sb);
    System.out.println(sb);
}

@Test
public void testTransfer4() {
    User user = new User();
    user.setAge(12);
    print(user);
    System.out.println(user);
}

@Test
public void testTransfer5() {
    User user = new User();
    user.setName("lily");
    List<User> users = Arrays.asList(user);
    print(users);
    System.out.println(users);
}

@Test
public void testTransfer6() {
    User user = new User();
    user.setName("lily");

    HashMap<String, User> map = new HashMap<>();
    map.put("user1", user);
    print(map);
    System.out.println(map);
}

@Test
public void testTransfer7() {
    List<Integer> nums = Arrays.asList(12);
    HashMap<String, Integer> map = new HashMap<>();
    map.put("abc", 123);
    print(nums, map);
    System.out.println(nums.get(0));
    System.out.println(map.get("abc"));
}

public void print(int num) {
    num++;
}

public void print(String str) {
    str += "123";
}

public void print(StringBuffer sb) {
    sb.append("123");
}

public void print(User user) {
    user.setName("lily");
}

public void print(List<User> userList) {
    if (userList != null && userList.size() > 0) {
        User user = userList.get(0);
        user.setAge(12);
    }
}

public void print(List<Integer> nums, Map<String, Integer> map) {
    Integer num1 = nums.get(0);
    num1 += 12;

    Integer num2 = map.get("abc");
    num2 += 23;

    System.out.println("print:num1:" + num1 + " ,num2:" + num2);
}


public void print(Map<String, User> map) {
    User user1 = map.get("user1");
    user1.setAge(13);
}
```
对于基本数据类型，传递的是其值，对于引用类型来讲，传递的是其引用（不包含String）。