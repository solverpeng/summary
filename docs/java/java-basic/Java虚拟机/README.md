# JAVA虚拟机
这里所说的虚拟机结构，单纯指的是运行时数据区。Java虚拟机规范，定义了运行时数据区包含：
1. PC寄存器
2. Java虚拟机栈
3. Java堆
4. 方法区
5. 运行时常量池
6. 本地方法栈

## PC寄存器
Java虚拟机规范中有如下说明：
1. Java虚拟机可以支持多条线程同时执行，每一条Java虚拟机线程都有自己的PC（Program Counter）寄存器
2. 在任意时刻，一条Java虚拟机线程只会执行一个方法的代码，这个正在被线程执行的方法称为该线程的当前方法（Current Method）。
3. 如果这个方法不是native的，那PC寄存器就保存Java虚拟机正在执行的字节码指令的地址，如果该方法是native的，那PC寄存器的值是undefined。

## 方法区
Java虚拟机规范中有如下说明：
1. 在Java虚拟机中，方法区（Method Area）是可供各条线程共享的运行时内存区域
2. 方法区存储了每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容、还包括一些在类、实例、接口初始化时用到的特殊方法。
3. 方法区在虚拟机启动的时候被创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择在这个区域不实现垃圾收集
4. 不限定实现方法区的内存位置和编译代码的管理策略
5. 如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。

## Java堆
Java虚拟机规范中有如下说明：
1. 在Java虚拟机中，堆（Heap）是可供各条线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。
2. Java堆在虚拟机启动的时候就被创建，它存储了被垃圾收集器所管理的各种对象，这些受管理的对象无需，也无法显式地被销毁。
3. 如果实际所需的堆超过了自动内存管理系统能提供的最大容量，那Java虚拟机将会抛出一个OutOfMemoryError异常。

## 运行时常量池
Java虚拟机规范中有如下说明：
1. 运行时常量池（Runtime Constant Pool）是每一个类或接口的常量池（Constant_Poo）的运行时表示形式
2. 每一个运行时常量池都分配在**Java虚拟机的方法区**之中，在类和接口被加载到虚拟机后，对应的运行时常量池就被创建出来。
3. 当创建类或接口的时候，如果构造运行时常量池所需要的内存空间超过了方法区所能提供的最大值，那Java虚拟机将会抛出一个OutOfMemoryError异常

## Java虚拟机栈
Java虚拟机规范中有如下说明：
1. 每一条Java虚拟机线程都有自己私有的Java虚拟机栈（Java Virtual Machine Stack），这个栈与线程同时创建，用于存储栈帧。
2. Java虚拟机栈的作用与传统语言（例如C语言）中的栈非常类似，就是用于存储局部变量与一些过程结果的地方.
3. 在方法调用和返回中也扮演了很重要的角色

> 请读者注意避免混淆Stack、Heap和Java （VM）Stack、Java Heap的概念，Java虚拟机的实现本身是由其他语言编写的应用程序，
在Java语言程序的角度上看分配在Java Stack中的数据，而在实现虚拟机的程序角度上看则可以是分配在Heap之中。

### 栈帧
1. 栈帧是用来存储数据和部分过程结果的数据结构，同时也被用来处理动态链接、方法返回值和异常分派
2. 栈帧随着方法调用而创建，随着方法结束而销毁——无论方法是正常完成还是异常完成（抛出了在方法内未被捕获的异常）都算作方法结束
3. 栈帧的存储空间分配在Java虚拟机栈之中，每一个栈帧都有自己的局部变量表、操作数栈和指向当前方法所属的类的运行时常量池的引用
4. 在一条线程之中，只有目前正在执行的那个方法的栈帧是活动的。这个栈帧就被称为是当前栈帧，这个栈帧对应的方法就被称为是当前方法，定义这个方法的类就称作当前类。对局部变量表和操作数栈的各种操作，通常都指的是对当前栈帧的对局部变量表和操作数栈进行的操作。

#### 局部变量表
1. 每个栈帧内部都包含一组称为局部变量表的变量列表。
2. 一个局部变量可以保存一个类型为boolean、byte、char、short、float、reference和returnAddress的数据，两个局部变量可以保存一个类型为long和double的数据。

3. 局部变量使用索引来进行定位访问，第一个局部变量的索引值为零，局部变量的索引值是从零至小于局部变量表最大容量的所有整数。
4. 当一个实例方法被调用的时候，第0个局部变量一定是用来存储被调用的实例方法所在的对象的引用（即Java语言中的“this”关键字）。后续的其他参数将会传递至从1开始的连续的局部变量表位置上。


#### 操作数栈
1. 每一个栈帧内部都包含一个称为操作数栈的后进先出（LIFO）栈。
2. 我们经常把“当前栈帧的操作数栈”直接简称为“操作数栈”。
3. 操作数栈所属的栈帧在刚刚被创建的时候，操作数栈是空的。Java虚拟机提供一些字节码指令来从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中，

   也提供了一些指令用于从操作数栈取走数据、操作数据和把操作结果重新入栈。在方法调用的时候，操作数栈也用来准备调用方法的参数以及接收方法返回结果。


## 本地方法栈
1. Java虚拟机实现可能会使用到传统的栈来支持native方法（指使用Java以外的其他语言编写的方法）的执行，这个栈就是本地方法栈（Native Method Stack）。
2. 如果线程请求分配的栈容量超过本地方法栈允许的最大容量时，Java虚拟机将会抛出一个StackOverflowError异常
3. 如果本地方法栈可以动态扩展，并且扩展的动作已经尝试过，但是目前无法申请到足够的内存去完成扩展，或者在建立新的线程时没有足够的内存去创建对应的本地方法栈，

   那Java虚拟机将会抛出一个OutOfMemoryError异常。
   
# 虚拟机实现
以Java HotSpot(TM) 64-Bit Server VM 为例。虚拟机运行时数据区包含：
1. PC寄存器
2. Java虚拟机栈
3. 本地方法栈
4. Java堆
    - 年轻代
    - 老年代
    - 元空间（也即方法区）
        - 运行时常量池
5. 直接内存

## Java虚拟机栈
栈空间是每个线程各自有的一块区域，如果栈空间太小，也会导致 StackOverFlow 异常。而要设置栈空间大小，只需要使用 -Xss 参数就可以。
```
java -Xss2m
```

### 函数如何调用：出入Java栈
如果说，Java堆和程序数据密切相关，那么Java栈就是和线程执行密切相关。线程执行的基本行为是函数调用，每次函数调用的数据都是通过Java栈传递的。
Java栈和数据结构上的栈有着类似的含义，它是一块先进后出的数据结构，只支持出栈和入栈两种操作。在Java栈中保存的主要内容为栈帧。每次函数调用，都会有一个栈帧被压入Java栈，每一个函数调用结束，都会有一个栈帧被弹出Java栈。当前正在执行的函数所对应的帧位于栈顶，它保存着当前函数的局部变量/中间运算结果等数据。当函数返回时，栈帧从Java栈中被弹出。Java方法有两种返回函数的方式。一种是正常函数返回，使用return指令；另一种是抛出异常。不管是那种方式，都会导致栈帧被弹出。在一个栈帧中，至少要包含局部变量表/操作数栈和帧数据区几个部分。

![](https://xiaozhang-image.oss-cn-shanghai.aliyuncs.com/github/java-summary/java-basic/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.png)

由于每次函数调用都会生成对应哪个的栈帧，从而占用一定的栈空间。若栈空间不足，那么函数调用自然无法继续，当请求的线程深度大于最大可用栈深度时，系统会抛出 StackOverflowError 栈溢出错误。Java虚拟机提供了 -Xss 来制定线程的最大栈空间，这个参数直接决定了函数调用的最大深度。

### 参数传递
```
@Test
public void testTransfer() {
    int num = 12;
    print(num);
    System.out.println(num);
}

@Test
public void testTransfer2() {
    String str = "abc";
    print(str);
    System.out.println(str);
}

@Test
public void testTransfer3() {
    StringBuffer sb = new StringBuffer("abc");
    print(sb);
    System.out.println(sb);
}

@Test
public void testTransfer4() {
    User user = new User();
    user.setAge(12);
    print(user);
    System.out.println(user);
}

@Test
public void testTransfer5() {
    User user = new User();
    user.setName("lily");
    List<User> users = Arrays.asList(user);
    print(users);
    System.out.println(users);
}

@Test
public void testTransfer6() {
    User user = new User();
    user.setName("lily");

    HashMap<String, User> map = new HashMap<>();
    map.put("user1", user);
    print(map);
    System.out.println(map);
}

@Test
public void testTransfer7() {
    List<Integer> nums = Arrays.asList(12);
    HashMap<String, Integer> map = new HashMap<>();
    map.put("abc", 123);
    print(nums, map);
    System.out.println(nums.get(0));
    System.out.println(map.get("abc"));
}

public void print(int num) {
    num++;
}

public void print(String str) {
    str += "123";
}

public void print(StringBuffer sb) {
    sb.append("123");
}

public void print(User user) {
    user.setName("lily");
}

public void print(List<User> userList) {
    if (userList != null && userList.size() > 0) {
        User user = userList.get(0);
        user.setAge(12);
    }
}

public void print(List<Integer> nums, Map<String, Integer> map) {
    Integer num1 = nums.get(0);
    num1 += 12;

    Integer num2 = map.get("abc");
    num2 += 23;

    System.out.println("print:num1:" + num1 + " ,num2:" + num2);
}


public void print(Map<String, User> map) {
    User user1 = map.get("user1");
    user1.setAge(13);
}
```
对于基本数据类型，传递的是其值，对于引用类型来讲，传递的是其引用（不包含String）。


## Java堆
```
Heap
 PSYoungGen      total 9216K, used 1807K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 22% used [0x00000000ff600000,0x00000000ff7c3f08,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
 ParOldGen       total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000)
 Metaspace       used 3533K, capacity 4594K, committed 4864K, reserved 1056768K
  class space    used 404K, capacity 426K, committed 512K, reserved 1048576K
```

### Java堆配置
使用 -Xms 设置堆的初始空间大小，使用 -Xmx 设置堆的最大空间大小。一般情况下，会将这两个值设置为相等。
```
java -Xms20m -Xmx30m -XX:+PrintGCDetails
```

### 年轻代（PSYoungGen）配置
参数 -Xmn 来设置年轻代内存的大小
```
java -Xms20m -Xmx20M -Xmn10m -XX:+PrintGCDetails
--------------
 PSYoungGen      total 9216K, used 1807K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 22% used [0x00000000ff600000,0x00000000ff7c3db0,0x00000000ffe00000)
  from space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)
  to   space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)
 ParOldGen       total 10240K, used 0K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)
  object space 10240K, 0% used [0x00000000fec00000,0x00000000fec00000,0x00000000ff600000)
```
#### eden/from eden/to
使用 -XX:SurvivorRatio 这个参数，该参数设置 eden/from 空间的比例关系，默认比例为8:1。
```-XX:SurvivorRatio = eden/from = eden/to```

```
java -Xms20m -Xmx20M -Xmn10m -XX:SurvivorRatio=2 -XX:+PrintGCDetails
--------------
Heap
 PSYoungGen      total 7680K, used 1627K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)
  eden space 5120K, 31% used [0x00000000ff600000,0x00000000ff796c60,0x00000000ffb00000)
  from space 2560K, 0% used [0x00000000ffd80000,0x00000000ffd80000,0x0000000100000000)
  to   space 2560K, 0% used [0x00000000ffb00000,0x00000000ffb00000,0x00000000ffd80000)
```
这里的 total 指的是可用内存，from space 和 to space 两个区域，同一时间只有一个区域是可以用的。

### 老年代配置
老年代不需要配置，老年代的大小就等于堆大小减去年轻代大小。

### 元空间
存在两个参数来设置元空间，` -XX:MetaspaceSize`和`-XX:MaxMetaspaceSize`。
` -XX:MetaspaceSize`表示元空间发生GC的初始阈值，达到这个值时，元空间发生GC，默认是20.8M。

`-XX:MaxMetaspaceSize` 则是设置元空间的最大大小，默认基本是机器的物理内存大小。
虽然可以不设置，但还是建议设置一下，因为如果一直不断膨胀，那么 JVM 进程可能会被 OS kill 掉。
```
java -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=50m -XX:+PrintGCDetails
--------------
Metaspace       used 3533K, capacity 4594K, committed 4864K, reserved 1056768K
  class space    used 404K, capacity 426K, committed 512K, reserved 1048576K
```

### Java堆相关参数
| 参数  | 含义 |
| ------------------------ | ------ |
-Xms |	初始堆大小 |
-Xmx |	最大堆空间 |
-Xmn |	设置新生代大小 |
-XX:SurvivorRatio |	设置新生代eden空间和from/to空间的比例关系 |
-XX:PermSize |	方法区初始大小 |
-XX:MaxPermSize |	方法区最大大小 |
-XX:MetaspaceSize |	元空间GC阈值（JDK1.8） |
-XX:MaxMetaspaceSize |	最大元空间大小（JDK1.8）|

### 对象去哪儿：Java堆
通过下面一个简单的实例，来展示Java堆/方法区和Java栈之间的关系
```java
public class SimpleHeap {
    private int id;

    public SimpleHeap(int id) {
        this.id = id;
    }

    private void show() {
        System.out.println("My Id is " + id);
    }

    public static void main(String[] args) {
        SimpleHeap s1 = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);

        s1.show();
        s2.show();
    }
}
```
声明了一个 SimpleHeap 类，并在main() 中创建了两个 SimpleHeap 实例。SimpleHeap 实例本身分配在堆中，描述 SimpleHeap类的信息存放在方法区，main()
函数中 s1 和 s2 局部变量存放在 Java 栈中，并指向堆中的两个实例。

![](https://xiaozhang-image.oss-cn-shanghai.aliyuncs.com/github/java-summary/java-basic/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.png)

## 直接内存
在 JVM 中还有一块内存，它独立于 JVM 的堆内存，它就是：直接内存。我们可以使用 -XX:MaxDirectMemorySize 设置最大直接内存。

如果不设置，默认为最大堆空间，即 -Xmx。

```
java -XX:MaxDirectMemorySize=50m
```
当直接内存使用达到设置值时，就会触发垃圾回收。如果不能有效释放足够空间，就会引发直接内存溢出导致系统的 OOM。



# 垃圾回收机制
## 作用范围
可对Java堆、方法区、运行时常量区垃圾对象进行回收。以Java HotSpot(TM) 64-Bit Server VM 为例，回收范围为Java堆和直接内存。

## 谁是垃圾?
如果一个对象不可能再被引用，那么这个对象就是垃圾，应该被回收。

根据这个思想，我们很容易想到使用引用计数的方法来判断垃圾。在一个对象被引用时加一，被去除引用时减一，这样我们就可以通过判断引用计数是否为零来判断一个对象是否为垃圾。这种方法我们一般称之为「引用计数法」。
上面的这种方法虽然简单，但是其存在一个致命的问题，那就是循环引用。
A 引用了 B，B 引用了 C，C 引用了 A，它们各自的引用计数都为 1。但是它们三个对象却从未被其他对象引用，只有它们自身互相引用。从垃圾的判断思想来看，它们三个确实是不被其他对象引用的，但是此时它们的引用计数却不为零。这就是引用计数法存在的循环引用问题。

而现今的 Java 虚拟机判断垃圾对象使用的是：GC Root Tracing 算法，大概的过程是这样：从 GC Root 出发，所有可达的对象都是存活的对象，而所有不可达的对象都是垃圾。
GC Root 就是一组活跃引用的集合。但是这个集合又与一般的对象集合不太一样，这些集合是经过特意筛选出来的，通常包括：
1. 所有当前被加载的 Java 类
2. Java 类的引用类型静态变量
3. Java类的运行时常量池里的引用类型常量
4. VM的一些静态数据结构里指向GC堆里的对象的引用

简单地说，GC Root 就是经过精心挑选的一组活跃引用，这些引用是肯定存活的。那么通过这些引用延伸到的对象，自然也是存活的。

### 谁才是真正的垃圾
垃圾回收的基本思想是考察每一个对象的可触及性。
可触及的：从根节点开始，可以到达这个对象。
可复活的：对象的所有引用都被释放，但是对象有可能在 finalize() 函数中复活。
不可触及的：对象的 finalize() 函数被调用，并且没有复活，那么就会进入不可触及状态，不可触及的对象不可能被复活，因此 finalize() 函数只会被调用一次。

finalize() 函数是一个非常糟糕的的模式，不推荐使用 finalize() 函数释放资源。
第一，因为 finalize() 函数可能引发引用外泄，在无意中复活对象。
第二，由于 finalize() 是被系统调用的，调用时间不明确，因此不是一个好的资源释放方案，推荐使用 try-catch-finally 语句中进行资源的释放。

### 引用和可触及性的强度
4个级别的引用：强引用/软引用/弱引用/虚引用，除强引用外，其他的3个级别的引用都可以在java.lang.ref包中找到他们的身影。

#### 强引用
强引用就是程序中一般的引用类型，强引用的对象是可触及的，不会被回收的。相对的，软引用/弱引用和虚引用的对象是软可触及的/弱可触及的和虚可触及的，在一定条件下，是可以被回收的。
一个例子：
StringBuffer str = new StringBuffer("hello world");
局部变量 str 指向 StringBuffer 实例所在的堆空间，通过 str 可以操作该实例，那么 str 就是StringBuffer实例的强引用。
此时，再运行一个赋值语句：
StringBuffer str1 = str;
那么 str 所指向的对象也将被 str1 所指向。

强引用具备以下特点：
1. 强引用可以直接访问目标对象
2. 强引用所指向的对象在任何时候都不会被回收，虚拟机宁愿抛出OOM异常，也不会回收强引用所指向的对象。
3. 强引用可能导致内存泄露。

#### 软引用（SoftReference）
软引用是比强引用弱一点的引用类型。一个对象只持有软引用，那么当堆空间不足时，就会被回收。
GC未必会回收软引用的对象，但是，当内存资源紧张时，软引用对象就会被回收，所以软引用对象不会引起内存溢出。

#### 弱引用
弱引用是一种比较弱的引用类型。在系统GC时，只要发现弱引用，不管堆空间如何，都会将对象进行回收。
但是，由于垃圾回收器的线程通常优先级较低，因此，并不能很快的发现持有弱引用的对象。在这种情况下，弱引用对象可以存在较长的时间。弱引用使用 java.lang.ref.WeakReference类实现。

软引用和弱引用都非常适合来保存那些可有可无的缓存数据。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。而当内存资源充足时，这些缓存数据有可以存在相当长的时间，从而起到加速系统的作用。

#### 虚引用
虚引用是所有引用类型中最弱的一个。一个持有虚引用的对象，和没有引用几乎是一模一样的，随时都可能被垃圾回收器回收。当试图通过虚引用的 get() 方法来得到强引用时，总会失败。并且虚引用必须和引用队列一起使用，它的作用在于跟踪垃圾回收过程。

当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。


## 垃圾回收算法
1. 标记清除法
   - 分为两个阶段，标记，清除
   - 标记阶段，标记所有从根节点开始的可达对象,未被标记的视为垃圾对象。
   - 清除阶段，清除所有未被标记的对象。
   - 缺点：回收后的空间是不连续的。在对象的堆空间分配过程中，尤其是大对象的内存分配，不连续的工作效率要低于连续的空间。
2. 复制算法
   - 将原有的内存分为两块，每次只使用其中的一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块，之后清除正在使用的内存块中所有的对象，交换两个内存的角色，完成垃圾回收.
   - 需要将系统内存折半
3. 标记压缩法
   - 分两个阶段，标记，压缩，清理
   - 标记阶段，标记所有从根节点开始的可达对象
   - 压缩阶段，将所有存活对象压缩到内存的一端
   - 之后清理边界外的所有空间

对比三种算法：
1. 标记清除算法虽然会产生内存碎片，但是不需要移动太多对象，比较适合在存活对象比较多的情况。
2. 复制算法虽然需要将内存空间折半，并且需要移动存活对象，但是其清理后不会有空间碎片，比较适合存活对象比较少的情况。
3. 标记压缩算法，则是标记清除算法的优化版，减少了空间碎片。

## 垃圾回收思想
### 分代思想
如果我们单独采用任何一种算法，那么最终的垃圾回收效率都不会很好。因此在实际的垃圾回收算法中采用了分代算法。

所谓分代算法，就是根据 JVM 内存的不同内存区域，采用不同的垃圾回收算法。
例如对于存活对象少的新生代区域，比较适合采用复制算法。这样只需要复制少量对象，便可完成垃圾回收，并且还不会有内存碎片。
而对于老年代这种存活对象多的区域，比较适合采用标记压缩算法或标记清除算法，这样不需要移动太多的内存对象。

试想一下，如果没有采用分代算法，而在老年代中使用复制算法。在极端情况下，老年代对象的存活率可以达到100%，
那么我们就需要复制这么多个对象到另外一个内存区域，这个工作量是非常庞大的。

在这里我们再深入地聊一聊新生代里采取的垃圾回收算法。如我们上面所说，新生代的特点是存活对象少，适合采用复制算法。
而复制算法的一种最简单实现便是折半内存使用，另一半备用。但实际上我们知道，在实际的 JVM 新生代划分中，却不是采用等分为两块内存的形式。
而是分为：Eden 区域、from 区域、to 区域 这三个区域。那么为什么 JVM 最终要采用这种形式，而不用 50% 等分为两个内存块的方式？

要解答这个问题，我们就需要先深入了解新生代对象的特点。
根据IBM公司的研究表明，在新生代中的对象 98% 是朝生夕死的，所以并不需要按照1:1的比例来划分内存空间。
所以在HotSpot虚拟机中，JVM 将内存划分为一块较大的Eden空间和两块较小的Survivor空间，其大小占比是8:1:1。
当回收时，将Eden和Survivor中还存活的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Eden空间。

通过这种方式，内存的空间利用率达到了90%，只有10%的空间是浪费掉了。而如果通过均分为两块内存，则其内存利用率只有 50%，两者利用率相差了将近一倍。
   
### 分区思想
分代思想按照对象的生命周期长短将其分为了两个部分（新生代、老年代），但 JVM 中其实还有一个分区思想，即将整个堆空间划分成连续的不同小区间。
每一个小区间都独立使用，独立回收，这种算法的好处是可以控制一次回收多少个区间，可以较好地控制 GC 时间。

## 垃圾回收器
总的来说，Java 虚拟机的垃圾回收器可以分为四大类别：串行回收器、并行回收器、CMS 回收器、G1 回收器。

### 串行回收器
串行回收器是指使用单线程进行垃圾回收的回收器。因为每次回收时只有一个线程，因此串行回收器在并发能力较弱的计算机上，其专注性和独占性的特点往往能让其有更好的性能表现。
串行回收器可以在新生代和老年代使用，根据作用于不同的堆空间，分为新生代串行回收器和老年代串行回收器。

#### 新生代串行回收器
串行收集器是所有垃圾回收器中最古老的一种，也是 JDK 中最基本的垃圾回收器之一。

在新生代串行回收器中使用的是复制算法。在串行回收器进行垃圾回收时，会触发 Stop-The-World 现象，即其他线程都需要暂停，等待垃圾回收完成。
因此在某些情况下，其会造成较为糟糕的用户体验。

使用 `-XX:+UseSerialGC` 参数可以指定使用新生代串行收集器和老年代串行收集器。当虚拟机在 Client 模式下运行时，其默认使用该垃圾收集器。

#### 老年代串行回收器
在老年代串行回收器中使用的是标记压缩算法。其与新生代串行收集器一样，只能串行、独占式地进行垃圾回收，因此也经常会有较长时间的 Stop-The-World 发生。

但老年代串行回收器的好处之一，就是其可以与多种新生代回收器配合使用。若要启用老年代串行回收器，可以尝试以下参数：
1. -XX:UseSerialGC：新生代、老年代都使用串行回收器。
2. -XX:UseParNewGC：新生代使用 ParNew 回收器，老年代使用串行回收器。
3. -XX:UseParallelGC：新生代使用 ParallelGC 回收器，老年代使用串行回收器。

### 并行回收器
并行回收器在串行回收器的基础上做了改进，其使用多线程进行垃圾回收。对于并行能力强的机器，可以有效缩短垃圾回收所使用的时间。
根据作用内存区域的不同，并行回收器也有三个不同的回收器：新生代 ParNew 回收器、新生代 ParallelGC 回收器、老年代 ParallelGC 回收器。

#### 新生代 ParNew 回收器
1. 工作在新生代，其只是简单地将串行回收器多线程化，其回收策略、算法以及参数和新生代串行回收器一样。
2. 同样使用复制的垃圾回收算法，其垃圾收集过程中同样会触发 Stop-The-World 现象。但因为其使用多线程进行垃圾回收，因此在并发能力强的 CPU 上，其产生的停顿时间要短于串行回收器。
3. 但在单 CPU 或并能能力弱的系统中，并行回收器效果会因为线程切换的原因，其实际表现反而不如串行回收器。

要开启新生代 ParNew 回收器，可以使用以下参数：
1. -XX:+UseParNewGC：新生代使用 ParNew 回收器，老年代使用串行回收器。
2. -XX:UseConcMarkSweepGC：新生代使用 ParNew 回收器，老年代使用 CMS。
3. -XX:ParallelGCThreads：指定 ParNew 回收器的工作线程数量。

#### 新生代 Parallel GC 回收器
新生代 Parallel GC 回收器与新生代 ParNew 回收器非常类似，其也是使用复制算法，都是多线程、独占式的收集器，也会导致 Stop-The-World。
但其与 ParNew 回收器的一个重大不同是：其非常注重系统的吞吐量。

之所以说新生代 Parallel GC 回收器非常注重系统吞吐量，是因为其有一个自适应 GC 调节策略。
我们可以使用 -XX:+UseAdaptiveSizePolicy 参数打开这个策略，在这个模式下，新生代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数都会被自动调节，已达到堆大小、吞吐量、停顿时间的平衡点。

Parallel GC 回收器提供了两个重要参数用于控制系统的吞吐量。
1. -XX:MaxGCPauseMillis：设置最大垃圾收集停顿时间。在 ParallelGC 工作时，其会自动调整响应参数，将停顿时间控制在设置范围内。为了达到目的，其可能会使用较小的堆，但这会导致 GC 较为频繁。
2. -XX:GCTimeRatio：设置吞吐量大小，其实一个 0 - 100 的整数。假设 GCTimeRatio 的值为 n，那么系统将不花费超过 1/(1+n) 的时间用于垃圾手机。比如 GCTimeRatio 值为 19，那么系统用于垃圾收集的时间不超过 1 /(1+19) = 5%。
   默认情况下，它的取值是 99，即不超过 1% 的时间用于垃圾收集。

新生代 Parallel GC 回收器可以使用以下参数启用：
1. -XX:+UseParallelGC：新生代使用 Parallel 回收器，老年代使用串行回收器。
2. -XX:+UseParallelOldGC：新生代使用 ParallelGC 回收器，老年代使用 ParallelOldGC 回收器。

#### 老年代 ParallelOldGC 回收器
老年代 ParallelOldGC 回收器也是一种多线程并发的回收器，与新生代 ParallelGC 收集器一样，其也是注重吞吐量的收集器，只不过其是作用于老年代。

ParallelOldGC 回收器使用的是标记压缩算法，只有在 JDK 1.6 中才可以使用。
我们可以使用-XX:UseParallelOldGC参数在新生代中使用 ParallelGC 收集器，在老年代中使用 ParallelOldGC 收集器。
参数 -XX:ParallelGCThreads也可以用于设置垃圾回收时的线程数量。

### CMS回收器
与 ParallelGC 和 ParallelOldGC 不同，CMS 回收器主要关注系统停顿时间。
CMS 回收器全称为 Concurrent Mark Sweep，意为标记清除算法，其是一个使用多线程并行回收的垃圾回收器。

#### 工作步骤
CMS 的主要工作步骤有：初始标记、并发标记、预清理、重新标记、并发清除和并发充值。
其中初始标记和重新标记是独占系统资源的，而其他阶段则可以和用户线程一起执行。

在整个 CMS 回收过程中，默认情况下会有预清理的操作，我们可以关闭开关 -XX:-CMSPrecleaningEnabled 不进行预清理。
因为重新标记是独占 CPU 的，因此如果新生代 GC 发生之后，立刻出发一次新生代 GC，那么停顿时间就会很长。
为了避免这种情况，预处理时会刻意等待一次新生代 GC 的发生，之后在进行预处理。

#### 主要参数
1. 启动 CMS 回收器可以使用参数：-XX:+UseConcMarkSweepGC，线程并发数量可以通过 -XX:ConcGCThreads 或 -XX:ParallelCMSThreads 参数设定。
2. 此外，我们还可以设置 -XX:CMSInitiatingOccupancyFraction 来指定老年代空间使用阈值。
   当老年代空间使用率达到这个阈值时，会执行一次 CMS 回收，而不像其他回收器一样等到内存不够用的时候才进行 GC。
3. 我们之前说过标记清除算法的缺点是会产生内存碎片，因此 CMS 回收器会产生较多内存碎片。
   我们可以使用 XX:+UseCMSCompactAtFullCollection 参数让 CMS 在完成垃圾回收后，进行一次内存碎片整理。
   使用 -XX:CMSFullGCsBeforeCompaction 参数设置进行多少次 CMS 回收后，进行一次内存压缩。
4. 此外，如果希望使用 CMS 回收 Perm 区，那么则可以打开 -XX:+CMSClassUnloadingEnabled 开关。    
   打开该开关后，如果条件允许，那么系统会使用 CMS 的机制回收 Perm 区 Class 数据。
   
### G1回收器
G1 回收器是 JDK 1.7 中使用的全新垃圾回收器，从长期目标来看，其是为了取代 CMS 回收器。

G1 回收器拥有独特的垃圾回收策略，和之前所有垃圾回收器采用的垃圾回收策略不同。从分代看，G1 依然属于分代垃圾回收器。
但它最大的改变是使用了分区算法，从而使得 Eden 区、From 区、Survivor 区和老年代等各块内存不必连续。

#### 工作步骤
G1 收集器的收集过程主要有四个阶段：
1. 新生代 GC
2. 并发标记周期
3. 混合收集
4. 如果需要，可能进行 FullGC

新生代 GC 与其他垃圾收集器的类似，就是清空 Eden 区，将存活对象移动到 Survivor 区，部分年龄到了就移动到老年代。

并发标记周期则分为：初始标记、根区域扫描、并发标记、重新标记、独占清理、并发清理阶段。其中初始标记、重新标记、独占清理是独占式的，会引起停顿。
并且初始标记会引发一次新生代 GC。在这个阶段，所有将要被回收的区域会被 G1 记录在一个称之为 Collection Set 的集合中。

混合回收阶段会首先针对 Collection Set 中的内存进行回收，因为这些垃圾比例较高。G1 回收器的名字 Garbage First 就是这个意思，垃圾优先处理的意思。
在混合回收的时候，也会执行多次新生代 GC 和 混合 GC，从而来进行内存的回收。

必要时进行 Full GC。当在回收阶段遇到内存不足时，G1 会停止垃圾回收并进行一次 Full GC，从而腾出更多空间进行垃圾回收。

#### 相关参数
1. 打开 G1 收集器，我们可以使用参数：`-XX:+UseG1GC。
2. 设置目标最大停顿时间，可以使用参数：-XX:MaxGCPauseMillis。
3. 设置 GC 工作线程数量，可以使用参数：-XX:ParallelGCThreads。
4. 设置堆使用率触发并发标记周期的执行，可以使用参数：-XX:InitiatingHeapOccupancyPercent。

# Class文件结构
高版本的Java虚拟机可以执行由低版本编译器生成的Class文件，但是低版本的编译器不能执行高版本生成的Class文件。

以魔数开头，紧跟两个大小版本号。版本号之后的常量池，常量池之后是类的访问修饰符、代表自身类的引用、父类引用及接口数量和实现的接口引用。
接口之后，字段的数量和描述、方法数量以及方法的描述，最后存放着类文件的属性信息。

包含字段、方法、接口、父类、访问标记、常量池、大小版本号、魔数、类本身的属性


# 类的装载、连接、初始化
当 Java 虚拟机将 Java 源码编译为字节码之后，虚拟机便可以将字节码读取进内存，从而进行解析、运行等整个过程，这个过程我们叫：Java 虚拟机的类加载机制。
JVM 虚拟机执行 class 字节码的过程可以分为七个阶段：加载、验证、准备、解析、初始化、使用、卸载。

## 加载
把代码数据加载到内存中。这个过程对于我们解答这道问题没有直接的关系，但这是类加载机制的一个过程，所以必须要提一下。

## 验证
当 JVM 加载完 Class 字节码文件并在方法区创建对应的 Class 对象之后，JVM 便会启动对该字节码流的校验，只有符合 JVM 字节码规范的文件才能被 JVM 正确执行。
这个校验过程大致可以分为下面几个类型：

1. JVM规范校验。
2. 代码逻辑校验。

当代码数据被加载到内存中后，虚拟机就会对代码数据进行校验，看看这份代码是不是真的按照JVM规范去写的。这个过程对于我们解答问题也没有直接的关系，但是了解类加载机制必须要知道有这个过程。

## 准备（重点）
当完成字节码文件的校验之后，JVM 便会开始为类变量分配内存并初始化。这里需要注意两个关键点，即内存分配的对象以及初始化的类型。
1. 内存分配的对象。Java 中的变量有「类变量」和「类成员变量」两种类型，「类变量」指的是被 static 修饰的变量，而其他所有类型的变量都属于「类成员变量」。在准备阶段，JVM 只会为「类变量」分配内存，而不会为「类成员变量」分配内存。「类成员变量」的内存分配需要等到初始化阶段才开始。
2. 初始化的类型。在准备阶段，JVM 会为类变量分配内存，并为其初始化。但是这里的初始化指的是为变量赋予 Java 语言中该数据类型的零值，而不是用户代码里初始化的值。

## 解析
当通过准备阶段之后，JVM 针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类引用进行解析。这个阶段的主要任务是将其在常量池中的符号引用替换成直接其在内存中的直接引用。

其实这个阶段对于我们来说也是几乎透明的，了解一下就好。

## 初始化（重点）
到了初始化阶段，用户定义的 Java 程序代码才真正开始执行。在这个阶段，JVM 会根据语句执行顺序对类对象进行初始化，一般来说当 JVM 遇到下面 5 种情况的时候会触发初始化：

1. 遇到 new、getstatic、putstatic、invokestatic 这四条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。
2. 使用 java.lang.reflect 包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
5. 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。

1. 类初始化方法。编译器会按照其出现顺序，收集类变量的赋值语句、静态代码块，最终组成类初始化方法。类初始化方法一般在类初始化的时候执行。
2. 对象初始化方法。编译器会按照其出现顺序，收集成员变量的赋值语句、普通代码块，最后收集构造函数的代码，最终组成对象初始化方法。对象初始化方法一般在实例化类对象的时候执行。

## 类初始化步骤
1. 确定类变量的初始值。

   在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。
2. 初始化入口方法。

   当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。
3. 初始化类构造器。

   JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。
4. 初始化对象构造器。

   JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。

## 类的执行顺序大概可以按照如下步骤
1. 确定类变量的初始值。在类加载的准备阶段，JVM 会为类变量初始化零值，这时候类变量会有一个初始的零值。如果是被 final 修饰的类变量，则直接会被初始成用户想要的值。
2. 初始化入口方法。当进入类加载的初始化阶段后，JVM 会寻找整个 main 方法入口，从而初始化 main 方法所在的整个类。当需要对一个类进行初始化时，会首先初始化类构造器（），之后初始化对象构造器（）。
3. 初始化类构造器。JVM 会按顺序收集类变量的赋值语句、静态代码块，最终组成类构造器由 JVM 执行。
4. 初始化对象构造器。JVM 会按照收集成员变量的赋值语句、普通代码块，最后收集构造方法，将它们组成对象构造器，最终由 JVM 执行。
5. 如果在初始化 main 方法所在类的时候遇到了其他类的初始化，那么就先加载对应的类，加载完成之后返回。如此反复循环，最终返回 main 方法所在类。

## JAVA代码编译和执行的过程
 JAVA 代码编译是由 Java 源码编译器来完成的，流程如下：
 源代码——词法分析器——Token流——语法分析器——语法树/抽象语法树——语义分析器——注解抽象语法树——字节码生成器——JVM字节码
 Java 字节码的执行是由 JVM 执行引擎来执行的，流程如下：
 JVM 字节码——机器无关代码优化——中间代码——机器相关优化——中间代码——寄存器分配器——中间代码——目标代码生成器——目标代码
 
 代码编译和执行的整个过程包含了一下三个重要的机制:
 ### Java 源码编译机制
 分析和输入到符号表——注解处理——语义分析和生成 class 文件
 
 ### 类加载机制
 JVM 类是通过 ClassLoader 及其子类来完成的，类的层次关系和加载顺序如下：
 自底向上检查类是否已经加载：
 Customer ClassLoader —— App ClassLoader —— Extension ClassLoader —— Bootstrap ClassLoader
 自顶向下尝试加载类：
 Bootstrap ClassLoader 负责加载 JRE/lib/rt.jar 包中所有的 class。
 Extension ClassLoader 负责加载`JRE/lib/*.jar` 包中所有的 class。
 App ClassLoader 负责加载 classpath 中指定的 jar 包以及目录中的 class。
 Customer ClassLoader 应用程序根据自己需要自定义类加载器。
 
 ### 类执行机制
 JVM 是基于栈的体系结构来执行 class 字节码的。线程创建后，都会产生程序计数器和栈，程序计数器存放下一条要执行的指令在方法内的偏移量，栈中存放一个个栈帧，每个栈帧对应着每个方法的每次调用，而栈帧又是有局部变量和操作数栈两部分组成，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。